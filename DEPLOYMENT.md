# Deployment Guide - Nexus Platform Backend

## Deploying to Render

### Option 1: Using render.yaml (Recommended)

1. **Push your code to GitHub**

   ```bash
   git add .
   git commit -m "Ready for deployment"
   git push origin main
   ```

2. **Connect to Render**

   - Go to [render.com](https://render.com)
   - Click "New" â†’ "Blueprint"
   - Connect your GitHub repository
   - Render will automatically detect `render.yaml`

3. **Configure Environment Variables**

   Render will auto-generate `SECRET_KEY`. You need to add:

   - `DATABASE_URL` - Automatically set if you use Render PostgreSQL
   - `REDIS_URL` - Add if you use Redis (optional, will use in-memory cache if not set)
   - `CORS_ORIGINS` - Set to your frontend URL (e.g., `https://your-frontend.onrender.com`)

4. **Deploy**
   - Click "Apply"
   - Wait for deployment to complete

### Option 2: Manual Configuration

1. **Create Web Service**

   - Go to Render Dashboard
   - Click "New" â†’ "Web Service"
   - Connect your GitHub repository

2. **Configure Build Settings**

   - **Name**: `nexus-platform-backend`
   - **Environment**: `Python 3`
   - **Build Command**: `pip install -r requirements.txt`
   - **Start Command**: `gunicorn -w 4 -b 0.0.0.0:$PORT run:app`

3. **Add PostgreSQL Database**

   - In Render Dashboard, click "New" â†’ "PostgreSQL"
   - Name it `nexus-platform-db`
   - Copy the **Internal Database URL**

4. **Environment Variables**

   Add these in Render Dashboard â†’ Environment:

   ```
   FLASK_ENV=production
   SECRET_KEY=<auto-generated-or-your-secret>
   DATABASE_URL=<your-postgres-url>
   CACHE_TYPE=simple
   CORS_ORIGINS=https://your-frontend-url.com
   MC_SIMULATIONS=100
   ```

5. **Optional: Add Redis**

   - Click "New" â†’ "Redis"
   - Copy the connection URL
   - Add `REDIS_URL` environment variable
   - Change `CACHE_TYPE` to `redis`

6. **Initialize Database**

   After first deployment, run this command in Render Shell:

   ```bash
   python -c "from backend.init_db import init_db; init_db()"
   ```

### Post-Deployment

1. **Test Your API**

   ```bash
   curl https://your-app.onrender.com/api/models/info
   ```

2. **Check Logs**

   - Go to Render Dashboard â†’ Your Service â†’ Logs
   - Look for startup messages

3. **Monitor Performance**
   - Render provides metrics in the dashboard
   - Check CPU and memory usage

---

## Deploying to Heroku

1. **Install Heroku CLI**

   ```bash
   # Download from heroku.com/cli
   ```

2. **Create Procfile**

   ```bash
   echo "web: gunicorn -w 4 run:app" > Procfile
   ```

3. **Create Heroku App**

   ```bash
   heroku create nexus-platform-backend
   ```

4. **Add PostgreSQL**

   ```bash
   heroku addons:create heroku-postgresql:mini
   ```

5. **Add Redis (Optional)**

   ```bash
   heroku addons:create heroku-redis:mini
   ```

6. **Set Environment Variables**

   ```bash
   heroku config:set FLASK_ENV=production
   heroku config:set SECRET_KEY=$(python -c "import os; print(os.urandom(24).hex())")
   heroku config:set CACHE_TYPE=redis
   ```

7. **Deploy**

   ```bash
   git push heroku main
   ```

8. **Initialize Database**

   ```bash
   heroku run python -c "from backend.init_db import init_db; init_db()"
   ```

9. **Open App**
   ```bash
   heroku open
   ```

---

## Deploying with Docker

### Using Docker Hub

1. **Build Image**

   ```bash
   docker build -t your-username/nexus-platform:latest .
   ```

2. **Push to Docker Hub**

   ```bash
   docker push your-username/nexus-platform:latest
   ```

3. **Deploy to Any Platform**
   - AWS ECS
   - Google Cloud Run
   - Azure Container Instances
   - DigitalOcean App Platform

### Using Docker Compose (VPS)

1. **Copy files to server**

   ```bash
   scp -r . user@your-server:/app
   ```

2. **SSH into server**

   ```bash
   ssh user@your-server
   cd /app
   ```

3. **Start services**

   ```bash
   docker-compose up -d
   ```

4. **Check status**
   ```bash
   docker-compose ps
   docker-compose logs backend
   ```

---

## Environment Variables Reference

| Variable         | Required | Default        | Description                   |
| ---------------- | -------- | -------------- | ----------------------------- |
| `FLASK_ENV`      | Yes      | development    | Environment mode              |
| `SECRET_KEY`     | Yes      | -              | Flask secret key              |
| `DATABASE_URL`   | Yes      | SQLite         | PostgreSQL connection URL     |
| `REDIS_URL`      | No       | -              | Redis connection URL          |
| `CACHE_TYPE`     | No       | simple         | Cache backend (simple/redis)  |
| `CORS_ORIGINS`   | No       | localhost:3000 | Allowed CORS origins          |
| `MC_SIMULATIONS` | No       | 100            | Monte Carlo simulations count |

---

## Troubleshooting

### "gunicorn: command not found"

**Solution**: Make sure `gunicorn>=21.0.0` is in `requirements.txt`

### "No module named 'flask'"

**Solution**: Ensure build command is `pip install -r requirements.txt`

### "Cannot connect to database"

**Solution**:

- Check `DATABASE_URL` is set correctly
- For Render, use the **Internal Database URL**
- Format: `postgresql://user:password@host:5432/dbname`

### "CORS errors from frontend"

**Solution**: Set `CORS_ORIGINS` to your frontend URL

### "Application timeout"

**Solution**:

- Reduce `MC_SIMULATIONS` to 50 for faster calculations
- Use Redis cache to avoid recalculations

### "Memory issues"

**Solution**:

- Reduce number of Gunicorn workers (try `-w 2`)
- Optimize Monte Carlo simulations
- Use larger instance type

---

## Performance Optimization

### For Production

1. **Use Redis Caching**

   ```
   CACHE_TYPE=redis
   REDIS_URL=redis://...
   ```

2. **Optimize Workers**

   ```bash
   # Formula: (2 Ã— CPU cores) + 1
   gunicorn -w 4 run:app  # For 2 CPUs
   ```

3. **Enable Logging**

   ```bash
   gunicorn -w 4 --log-level=info --access-logfile=- run:app
   ```

4. **Set Timeouts**
   ```bash
   gunicorn -w 4 --timeout=120 run:app
   ```

---

## Security Checklist

Before deploying to production:

- [ ] Strong `SECRET_KEY` set (not the default)
- [ ] `FLASK_ENV=production`
- [ ] PostgreSQL with strong password
- [ ] CORS properly configured (not `*`)
- [ ] HTTPS enabled (Render does this automatically)
- [ ] Environment variables in platform (not in code)
- [ ] `.env` file in `.gitignore`
- [ ] Database backups configured
- [ ] Monitoring/logging enabled

---

## Next Steps After Deployment

1. **Test All Endpoints**

   ```bash
   curl https://your-app.com/api/scenarios
   curl https://your-app.com/api/models/info
   ```

2. **Monitor Performance**

   - Check response times
   - Monitor error rates
   - Watch database load

3. **Set Up Monitoring** (Recommended)

   - Sentry for error tracking
   - New Relic/Datadog for APM
   - Render's built-in metrics

4. **Configure Alerts**
   - Uptime monitoring
   - Error rate alerts
   - Performance degradation

---

## Support

For deployment issues:

- Check Render docs: https://render.com/docs
- Review application logs
- Test locally with production settings first

**Your API is production-ready! ðŸš€**
